<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="BillyYccc">
<meta property="og:url" content="http://billyyccc.github.io/index.html">
<meta property="og:site_name" content="BillyYccc">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BillyYccc">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '2WWMQACOEP',
      apiKey: 'f8df1743d538473615c64518eda8b29a',
      indexName: 'indexName',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://billyyccc.github.io/"/>





  <title> BillyYccc </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-99992019-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6e4315659b71ca3dac21c91ab1d6082c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BillyYccc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/19/设计模式（24）：访问者模式VISITOR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/设计模式（24）：访问者模式VISITOR/" itemprop="url">
                  设计模式（24）：访问者模式VISITOR
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T20:36:47+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在下列情况下使用Visitor模式：</p>
<ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。</li>
<li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>访问者模式结构如下<br><img src="/2017/06/19/设计模式（24）：访问者模式VISITOR/Visitor1.png" alt="ShowImage"></p>
<ul>
<li><p>Visitor<br><br> – 为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的方法名和参数标识了发送Visit请求给该Visitor的那个类。这使得Visitor可以确定正被访问元素的具体的类。这样Visitor就可以通过该元素的特定接口直接访问它。</p>
</li>
<li><p>ConcreteVisitor<br><br> – 实现每个由Visitor声明的操作。每一个操作实现了Structure对象中相关的类所定义的算法的一部分。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。</p>
</li>
<li><p>Element<br><br> – 定义一个Accept操作，它以一个访问者为参数。</p>
</li>
<li><p>ConcreteElement<br><br> – 实现Accept操作，该操作以一个访问者为参数。</p>
</li>
<li><p>ObjectStructure<br><br> – 能枚举它的元素。<br><br> – 可以提供一个高层的接口以允许该访问者访问它的元素。<br><br> – 可以是一个Composite模式或是一个集合，如一个列表或一个无序集合。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li>一个使用Visitor模式的Client必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。</li>
<li>当一个元素被访问时，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。</li>
</ul>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li><p>访问者模式使得易于增加新的操作<br><br> – 访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的Visitor即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。</p>
</li>
<li><p>访问者集中相关的操作而分离无关的操作<br><br> – 相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个Visitor中。无关行为却被分别放在它们各自的Visitor子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。</p>
</li>
<li><p>增加新的ConcreteElement类很困难<br><br> – Visitor模式使得难以增加新的Element的子类。每添加一个新的ConcreteElement都要在Visitor中添加一个新的抽象操作，并在每一个ConcreteElement类中实现相应的操作。有时可以在Visitor中提供一个缺省的实现，这一实现可以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcreteElement类加入进来的话，Visitor类层次将变得难以维护。在这种情况下，直接在构成该结构的类中定义这些操作可能更容易一些。如果Element类层次是稳定的，而你不断地增加操作获修改算法，访问者模式可以帮助你管理这些改动。</p>
</li>
<li><p>通过类层次进行访问<br><br> – 一个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作，而Visitor可以对不同类型对象进行操作。</p>
</li>
<li><p>累积状态<br><br> – 当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。</p>
</li>
<li><p>破坏封装<br><br> – 访问者方法假定ConcreteElement接口的功能足够强，足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。</p>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/19/设计模式（24）：访问者模式VISITOR/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/16/设计模式（23）：中介者模式MEDIATOR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/16/设计模式（23）：中介者模式MEDIATOR/" itemprop="url">
                  设计模式（23）：中介者模式MEDIATOR
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-16T14:40:11+08:00">
                2017-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在下列情况下使用中介者模式:</p>
<ul>
<li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</li>
<li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>中介者模式结构如下<br><img src="/2017/06/16/设计模式（23）：中介者模式MEDIATOR/Mediator1.png" alt="ShowImage"></p>
<ul>
<li><p>Mediator<br><br> – 中介者定义一个接口用于与各同事(Colleague)对象通信。</p>
</li>
<li><p>ConcreteMediator<br><br> – 具体中介者通过协调各同事对象实现协作行为。<br><br> – 了解并维护它的各个同事。</p>
</li>
<li><p>Colleague<br><br> – 每一个同事类都知道它的中介者对象。<br><br> – 每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>Colleague向一个Mediator对象发送和接收请求。Mediator在各Coleague间适当地转发请求以实现协作行为。</p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>中介者模式有以下优点和缺点:</p>
<ol>
<li><p>减少了子类生成<br><br>Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Mediator的子类即可。这样各个Colleague类可被重用。</p>
</li>
<li><p>它将各Colleague解耦<br><br>Mediator有利于各Colleague间的松耦合. 你可以独立的改变和复用各Colleague类和Mediator类。</p>
</li>
<li><p>它简化了对象协议<br><br>用Mediator和各Colleague间的一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。</p>
</li>
<li><p>它对对象如何协作进行了抽象<br><br>将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。</p>
</li>
<li><p>它使控制集中化<br><br>中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装<br>了协议, 它可能变得比任一个Colleague都复杂。这可能使得中介者自身成为一个难于维护的<br>庞然大物。</p>
</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/16/设计模式（23）：中介者模式MEDIATOR/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/15/设计模式（22）：迭代器模式ITERATOR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/15/设计模式（22）：迭代器模式ITERATOR/" itemprop="url">
                  设计模式（22）：迭代器模式ITERATOR
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T14:59:30+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式(Iterator)又可以称为游标(Cursor)。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>迭代器模式可用来：</p>
<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>支持对聚合对象的多种遍历。</li>
<li>为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>迭代器模式结构如下<br><img src="/2017/06/15/设计模式（22）：迭代器模式ITERATOR/Iterator1.png" alt="ShowImage"></p>
<ul>
<li><p>Iterator（迭代器）<br><br> – 迭代器定义访问和遍历元素的接口。</p>
</li>
<li><p>ConcreteIterator（具体迭代器）<br><br> – 具体迭代器实现迭代器接口。<br><br> – 对该聚合遍历时跟踪当前位置。</p>
</li>
<li><p>Aggregate（聚合）<br><br> – 聚合定义创建相应迭代器对象的接口。</p>
</li>
<li><p>ConcreteAggregate（具体聚合）<br><br> – 具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>迭代器模式有三个重要的作用：</p>
<ol>
<li><p>它支持以不同的方式遍历一个聚合复杂的聚合可用多种方式进行遍历。<br><br>迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可。你也可以自己定义迭代器的子类以支持新的遍历。</p>
</li>
<li><p>迭代器简化了聚合的接口<br><br>有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。</p>
</li>
<li><p>在同一个聚合上可以有多个遍历<br><br>每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。</p>
</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/15/设计模式（22）：迭代器模式ITERATOR/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/13/设计模式（21）：观察者模式OBSERVER/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/13/设计模式（21）：观察者模式OBSERVER/" itemprop="url">
                  设计模式（21）：观察者模式OBSERVER
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-13T18:05:18+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式(Observer)又可以称为发布-订阅模式(Publish-Subscribe)</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下任一情况下可以使用观察者模式：</p>
<ul>
<li>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>观察者模式结构如下<br><img src="/2017/06/13/设计模式（21）：观察者模式OBSERVER/Observer1.png" alt="ShowImage"></p>
<ul>
<li><p>Subject（目标）<br><br> – 目标知道它的观察者。可以有任意多个观察者观察同一个目标。<br><br> – 提供注册和删除观察者对象的接口。</p>
</li>
<li><p>Observer（观察者）<br><br> – 为那些在目标发生改变时需获得通知的对象定义一个更新接口。</p>
</li>
<li><p>ConcreteSubject（具体目标）<br><br> – 将有关状态存入各ConcreteObserver对象。<br><br> – 当它的状态发生改变时, 向它的各个观察者发出通知。</p>
</li>
<li><p>ConcreteObserver（具体观察者）<br><br> – 维护一个指向ConcreteSubject对象的引用。<br><br> – 存储有关状态，这些状态应与目标的状态保持一致。<br><br> – 实现Observer的更新接口以使自身状态与目标的状态保持一致。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li>当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。</li>
<li>在得到一个具体目标的改变通知后, ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li>
</ul>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>  Observer模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者, 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。<br>下面是观察者模式其它一些优缺点：</p>
<ul>
<li>目标和观察者间的抽象耦合<br><br>一个目标所知道的仅仅是它有一系列观察者, 每个都符合抽象的Observer类的简单接口。目标不知道任何一个观察者属于哪一个具体的类。这样目标和观察者之间的耦合是抽象的和最小的。</li>
<li>支持广播通信<br><br>不像通常的请求, 目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣；它唯一的责任就是通知它的各观察者。这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。</li>
<li>意外的更新<br><br>因为一个观察者并不知道其它观察者的存在, 它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外, 如果依赖准则的定义或维护不当，常常会引起错误的更新, 这种错误通常很难捕捉。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/13/设计模式（21）：观察者模式OBSERVER/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/10/设计模式（20）：职责链模式CHAINOFRESPONSIBILITY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/10/设计模式（20）：职责链模式CHAINOFRESPONSIBILITY/" itemprop="url">
                  设计模式（20）：职责链模式CHAINOFRESPONSIBILITY
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-10T13:37:45+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下条件下使用职责链：</p>
<ul>
<li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</li>
<li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li>
<li>可处理一个请求的对象集合应被动态指定。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>职责链模式结构如下<br><img src="/2017/06/10/设计模式（20）：职责链模式CHAINOFRESPONSIBILITY/ChainOfResponsibility1.png" alt="ShowImage"></p>
<ul>
<li><p>Handler<br><br> – 定义一个处理请求的接口。<br><br> – (可选) 实现后继链。</p>
</li>
<li><p>ConcreteHandler<br><br> – 处理它所负责的请求。<br><br> – 可访问它的后继者。<br><br> – 如果可处理该请求，就处理之；否则将该请求转发给它的后继者。</p>
</li>
<li><p>Client<br><br> – 向链上的具体处理者(ConcreteHandler)对象提交请求。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。</p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>职责链有下列优点和缺点：</p>
<ul>
<li>降低耦合度<br><br>该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。结果是，职责链可简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</li>
<li>增强了给对象指派职责( Responsibility)的灵活性<br><br>当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态地指定Handler的继承机制结合起来使用。</li>
<li>不保证请求被接受<br><br>既然一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/10/设计模式（20）：职责链模式CHAINOFRESPONSIBILITY/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/07/设计模式（19）：备忘录模式MEMENTO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/07/设计模式（19）：备忘录模式MEMENTO/" itemprop="url">
                  设计模式（19）：备忘录模式MEMENTO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-07T23:25:37+08:00">
                2017-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下情况下使用备忘录模式：</p>
<ul>
<li>必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。</li>
<li>支持取消操作。</li>
<li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>备忘录模式结构如下<br><img src="/2017/06/07/设计模式（19）：备忘录模式MEMENTO/Memento1.png" alt="ShowImage"></p>
<ul>
<li><p>Memento(备忘录)<br><br> – Memento存储Originator对象的内部状态。Originator根据需要决定Memento存储Originator的哪些内部状态。<br><br> – 防止Originator以外的其他对象访问Memento。Memento实际上有两个接口，管理者(caretaker)只能看到Memento的窄接口—它只能将Memento传递给其他对象。相反, Originator能够看到一个宽接口, 允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本Memento的那个原发器访问本Memento的内部状态。</p>
</li>
<li><p>Originator(原发器)<br><br> – Originator创建一个Memento,用以记录当前时刻它的内部状态。<br><br> – 使用Memento恢复内部状态。</p>
</li>
<li><p>Caretaker(管理器)<br><br> – 负责保存好Memento。<br><br> – 不能对Memento的内容进行操作或检查。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li>Caretaker向Originator请求一个Memento，保留一段时间后，将其送回给Originator。有时Caretaker不会将Memento返回给Originator, 因为Originator可能根本不需要退到先前的状态。</li>
<li>Memento是被动的。只有创建Memento的Originator会对它的状态进行赋值和检索。</li>
</ul>
<p>时序图如下所示<br><img src="/2017/06/07/设计模式（19）：备忘录模式MEMENTO/Memento2.png" alt="ShowImage"></p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li><p>保持封装边界<br><br> – 使用备忘录可以避免暴露一些只应由Originator管理却又必须存储在Originator之外的信息。该模式把可能很复杂的Originator内部信息对其他对象屏蔽起来, 从而保持了封装边界。</p>
</li>
<li><p>它简化了Originator<br><br> – 在其他的保持封装性的设计中, Originator负责保持客户请求过的内部状态版本。这就把所有存储管理的重任交给了Originator。让客户管理它们请求的状态将会简化Originator, 并且使得客户工作结束时无需通知原发器。</p>
</li>
<li><p>使用备忘录可能代价很高<br><br> – 如果原发器在生成备忘录时必须拷贝并存储大量的信息, 或者客户非常频繁地创建备忘录和恢复Originator状态，可能会导致非常大的开销。除非封装和恢复Originator状态的开销不大, 否则该模式可能并不合适。</p>
</li>
<li><p>定义窄接口和宽接口<br><br> – 在一些语言中可能难以保证只有原发器可访问备忘录的状态。</p>
</li>
<li><p>维护备忘录的潜在代价<br><br> – 管理器负责删除它所维护的备忘录。然而, 管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。</p>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/07/设计模式（19）：备忘录模式MEMENTO/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/05/设计模式（18）：命令模式COMMAND/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/05/设计模式（18）：命令模式COMMAND/" itemprop="url">
                  设计模式（18）：命令模式COMMAND
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T22:40:15+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个请求封装为一个对象，从而使你可以在接收不同的请求、请求队列或者日志请求时对客户进行参数化，并且支持可撤消的操作。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当你有如下需求时，可使用Command模式：</p>
<ul>
<li>可以抽象出待执行的动作以参数化某对象。<br><br>你可用过程语言中的回调(callback)函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。</li>
<li>在不同的时刻指定、排列和执行请求。</li>
<li>支持取消操作。</li>
<li>Command模式提供了对事务进行建模的方法。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>命令模式结构如下<br><img src="/2017/06/05/设计模式（18）：命令模式COMMAND/Command1.png" alt="ShowImage"></p>
<ul>
<li><p>Command<br><br> – 声明执行操作的接口。</p>
</li>
<li><p>ConcreteCommand<br><br> – 将一个Receiver对象与一个Action绑定。<br><br> – 调用接收者相应的操作，以实现Execute。</p>
</li>
<li><p>Client<br><br> – 创建一个Concrete Command对象并设定它的Receiver。</p>
</li>
<li><p>Invoker<br><br> – 要求该命令执行这个请求。</p>
</li>
<li><p>Receiver<br><br> – 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个Receiver。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ol>
<li>Client创建一个ConcreteCommand对象并指定它的Receiver对象。</li>
<li>某Invoker对象存储该ConcreteCommand对象。</li>
<li>该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤消的，ConcreteCommand就在执行Excute操作之前存储当前状态以用于取消该命令。</li>
<li>ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求。</li>
</ol>
<p>时序图如下所示<br><img src="/2017/06/05/设计模式（18）：命令模式COMMAND/Command2.png" alt="ShowImage"></p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>Command模式将调用操作的对象与知道如何实现该操作的对象解耦。</li>
<li>Command是顶层的对象。它们可像其他的对象一样被操纵和扩展。</li>
<li>你可将多个命令装配成一个复合命令</li>
<li>扩展性良好，增加新的Command很容易，因为这无需改变已有的类。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/05/设计模式（18）：命令模式COMMAND/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/04/设计模式（17）：模板方法TEMPLATEMETHOD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/04/设计模式（17）：模板方法TEMPLATEMETHOD/" itemprop="url">
                  设计模式（17）：模板方法TEMPLATEMETHOD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T15:22:37+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>模板方法应用于下列情况：</p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>控制子类扩展。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>模板方法结构如下<br><img src="/2017/06/04/设计模式（17）：模板方法TEMPLATEMETHOD/TemplateMethod1.png" alt="ShowImage"></p>
<ul>
<li><p>AbstractClass<br><br> – 定义抽象的基本操作(Primitive Operation)，具体的子类将重写它们来实现一个指定算法的步骤。<br><br> – 实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用接口中的基本操作，也调用定义在AbstractClass或其他对象中的操作。</p>
</li>
<li><p>ConcreteClass<br><br> – 实现基本操作来完成算法中与指定子类相关的步骤。</p>
</li>
</ul>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>ConcreteClass靠AbstractClass来实现算法中不变的步骤。</p>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>模板方法模式是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。</p>
<ul>
<li>模板方法模式使得扩展性更好</li>
<li>模板方法指定了逻辑，如果为模板方法添加final修饰符，那么子类也不能去修改逻辑。</li>
<li>钩子方法(Hook Method)在抽象中提供一个方法的空实现，子类可以根据自身需要来决定是否进行实现扩展。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/04/设计模式（17）：模板方法TEMPLATEMETHOD/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/03/设计模式（16）：状态模式STATE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/03/设计模式（16）：状态模式STATE/" itemprop="url">
                  设计模式（16）：状态模式STATE
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-03T21:32:17+08:00">
                2017-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式(Strategy Pattern)又名状态对象(Objects for States)</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当出现下面的两种情况之一时使用State模式</p>
<ul>
<li>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</li>
<li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>状态模式结构如下<br><img src="/2017/06/03/设计模式（16）：状态模式STATE/State1.png" alt="ShowImage"></p>
<ul>
<li><p>Context<br><br> – 定义Client所关注的接口。<br><br> – 维护一个ConcreteState子类的实例，这个实例定义当前状态。</p>
</li>
<li><p>State<br><br> – 定义一个接口以封装与Context的一个特定状态相关的行为。</p>
</li>
<li><p>ConcreteState subclasses<br><br> – 每一子类实现一个与Context的一个状态相关的行为。</p>
</li>
</ul>
<hr>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li>Context将与状态相关的请求委托给当前的ConcreteState对象处理。</li>
<li>Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context。</li>
<li>Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕, 它的Client不再需要直接与状态对象打交道。</li>
<li>Context或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li>
</ul>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>State模式有下面一些效果</p>
<ul>
<li>它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来<br><br> – State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。<br><br> – State模式避免使用大量的ifelse语句或者switchcase语句来控制状态，但是可能会引入更多的类，增加了子类的数目</li>
<li>它使得状态转换显式化<br><br> – 当一个对象仅以内部数据值来定义当前状态时, 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从Context的角度看，状态转换是原子的–只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值。</li>
<li>State对象可被共享<br><br> – 如果State对象没有实例变量–即它们表示的状态完全以它们的类型来编码–那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象(Flyweight Pattern)。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/03/设计模式（16）：状态模式STATE/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/06/02/设计模式（15）：策略模式STRATEGY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/02/设计模式（15）：策略模式STRATEGY/" itemprop="url">
                  设计模式（15）：策略模式STRATEGY
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-02T13:56:00+08:00">
                2017-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DesignPatterns/" itemprop="url" rel="index">
                    <span itemprop="name">DesignPatterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式(Strategy Pattern)又名政策模式(Policy Pattern)</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当存在以下情况时使用Strategy模式</p>
<ul>
<li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>策略模式结构如下<br><img src="/2017/06/02/设计模式（15）：策略模式STRATEGY/Strategy1.png" alt="ShowImage"></p>
<ul>
<li><p>Strategy<br><br> – 定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。</p>
</li>
<li><p>ConcreteStrategy<br><br> – 以Strategy接口实现某具体算法。</p>
</li>
<li><p>Context<br><br> – 用一个ConcreteStrategy对象来配置。<br><br> – 维护一个对Strategy对象的引用。<br><br> – 可定义一个接口来让Strategy访问它的数据。</p>
</li>
</ul>
<hr>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ul>
<li><p>Strategy和Context相互作用以实现选定的算法。当算法被调用时, Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。</p>
</li>
<li><p>Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context；这样, 客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。</p>
</li>
</ul>
<hr>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Strategy类层次为Context定义了一系列的可供重用的算法或行为。将Context与Strategy层次进行了解耦，不需要通过继承Context增加Context子类来完成策略的实现，这样易于扩展。</li>
<li>消除了大量条件语句，大量的使用条件语句使得代码看上去十分混乱</li>
<li>Strategy模式可以提供相同行为的不同实现。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>Client要想选择一个合适的Strategy，就必须去了解Strategy的具体区别，此时可能会向Client暴露具体的实现</li>
<li>增加了Strategy与Context之间的通信开销</li>
<li>增加了对象的数量</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/02/设计模式（15）：策略模式STRATEGY/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
       
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Billy Yuan" />
          <p class="site-author-name" itemprop="name">Billy Yuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Billy Yuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



  

  

  

  

</body>
</html>

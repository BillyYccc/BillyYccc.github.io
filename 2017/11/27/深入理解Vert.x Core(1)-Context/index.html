<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Convergence:300,300italic,400,400italic,700,700italic|Tauri:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Java,Vert.x," />










<meta name="description" content="Context在Vert.x核心组件概览一文中已经谈到了Context的基本概念，在更加深入地了解VertxImpl，Verticle的内部原理等等之前，有必要了解Context的一些内部机制。本文将对Vert.x的Context进行深入分析。
先来看下Context的结构

最顶层的是Context接口，下面是ContextInternal接口，这个接口是提供给Vert.x内部使用的API，Co">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Vert.x Core(1)-Context">
<meta property="og:url" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/index.html">
<meta property="og:site_name" content="BillyYccc">
<meta property="og:description" content="Context在Vert.x核心组件概览一文中已经谈到了Context的基本概念，在更加深入地了解VertxImpl，Verticle的内部原理等等之前，有必要了解Context的一些内部机制。本文将对Vert.x的Context进行深入分析。
先来看下Context的结构

最顶层的是Context接口，下面是ContextInternal接口，这个接口是提供给Vert.x内部使用的API，Co">
<meta property="og:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/ContextStructure.png">
<meta property="og:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/EventLoopContext.png">
<meta property="og:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/ContextImpl.png">
<meta property="og:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/TaskQueue.png">
<meta property="og:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/TaskQueueExecution.png">
<meta property="og:updated_time" content="2017-12-18T12:38:35.810Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Vert.x Core(1)-Context">
<meta name="twitter:description" content="Context在Vert.x核心组件概览一文中已经谈到了Context的基本概念，在更加深入地了解VertxImpl，Verticle的内部原理等等之前，有必要了解Context的一些内部机制。本文将对Vert.x的Context进行深入分析。
先来看下Context的结构

最顶层的是Context接口，下面是ContextInternal接口，这个接口是提供给Vert.x内部使用的API，Co">
<meta name="twitter:image" content="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/ContextStructure.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '2WWMQACOEP',
      apiKey: 'f8df1743d538473615c64518eda8b29a',
      indexName: 'indexName',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/"/>





  <title>深入理解Vert.x Core(1)-Context | BillyYccc</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-99992019-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6e4315659b71ca3dac21c91ab1d6082c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BillyYccc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://billyyccc.github.io/2017/11/27/深入理解Vert.x Core(1)-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Billy Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BillyYccc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Vert.x Core(1)-Context</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T14:59:26+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vert-x/" itemprop="url" rel="index">
                    <span itemprop="name">Vert.x</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>在<a href="http://billyyccc.com/2017/11/26/Vert.x核心组件概览#Context" target="_blank" rel="external">Vert.x核心组件概览</a>一文中已经谈到了Context的基本概念，在更加深入地了解VertxImpl，Verticle的内部原理等等之前，有必要了解Context的一些内部机制。本文将对Vert.x的Context进行深入分析。</p>
<p>先来看下Context的结构</p>
<p><img src="/2017/11/27/深入理解Vert.x Core(1)-Context/ContextStructure.png" alt="ShowImage"></p>
<p>最顶层的是<code>Context</code>接口，下面是<code>ContextInternal</code>接口，这个接口是提供给Vert.x内部使用的API，<code>ContextImpl</code>是一个抽象类，包含了Context的基本属性以及方法，再往下层就是Context的实现类，其实看到源码可以知道Vert.x中一共有四种Context，但是这个BenchmarkContext的目的不是给用户使用的，它主要被用来对Vert.x一些关键部分进行性能测试，比如Json的编解码、HTTP头部编码、HTTP Handler处理HttpRequest和HttpResponse的速度等等…可以参考<a href="https://github.com/eclipse/vert.x/blob/master/benchmarks.md" target="_blank" rel="external">这里</a>。就是说，真正在Vert.x中应用的Context就三种。三种Context使用的场景在这里就不再介绍，可以参考对应Verticle的<a href="http://billyyccc.com/2017/11/26/Vert.x核心组件概览#Verticle" target="_blank" rel="external">用途</a>。</p>
<a id="more"></a>
<h3 id="EventLoopContext"><a href="#EventLoopContext" class="headerlink" title="EventLoopContext"></a>EventLoopContext</h3><p>我们先对EventLoopContext进行分析。</p>
<p><img src="/2017/11/27/深入理解Vert.x Core(1)-Context/EventLoopContext.png" alt="ShowImage"></p>
<h4 id="isEventLoopContext-isMultiThreadedWorkerContext"><a href="#isEventLoopContext-isMultiThreadedWorkerContext" class="headerlink" title="isEventLoopContext(),isMultiThreadedWorkerContext()"></a>isEventLoopContext(),isMultiThreadedWorkerContext()</h4><p>EventLoopContext本身只有几个方法，<code>isEventLoopContext()</code>方法和<code>isMultiThreadedWorkerContext()</code>方法就不用多说了，继承<code>ContextImpl</code>中的抽象方法，表明自己身份用的。</p>
<h4 id="checkCorrectThread"><a href="#checkCorrectThread" class="headerlink" title="checkCorrectThread()"></a>checkCorrectThread()</h4><p>先看下<code>checkCorrectThread</code>方法，这个是实现了<code>ContextImpl</code>类中抽象方法的方法，会去判断当前线程是不是Vertx线程，如果是Vertx线程还会判断context的线程和当前线程是不是相同线程，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkCorrectThread</span><span class="params">()</span> </span>&#123;</div><div class="line">  Thread current = Thread.currentThread();</div><div class="line">  <span class="keyword">if</span> (!(current <span class="keyword">instanceof</span> VertxThread)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Expected to be on Vert.x thread, but actually on: "</span> + current);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contextThread != <span class="keyword">null</span> &amp;&amp; current != contextThread) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Event delivered on unexpected thread "</span> + current + <span class="string">" expected: "</span> + contextThread);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="executeAsync"><a href="#executeAsync" class="headerlink" title="executeAsync()"></a>executeAsync()</h4><p>接着看<code>executeAsync()</code>方法，在抽象类<code>ContextImpl</code>中也声明了<code>executeAsync()</code>抽象方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span></span>;</div></pre></td></tr></table></figure></p>
<p>找到实际调用这个方法的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run the task asynchronously on this same context</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runOnContext</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      executeAsync(task);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</div><div class="line">      <span class="comment">// Pool is already shut down</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><code>ContextImpl</code>这个类中多次用到了模板方法的设计模式，例如上面的<code>executeAsync()</code>和<code>checkCorrectThread()</code>都用到了，将抽象方法写在指定逻辑中，然后交给子类去实现这些抽象方法。</p>
<p><code>runOnContext()</code>方法是定义在<code>Context</code>接口中的，用来<strong>指明</strong>在<strong>当前context</strong>中异步地执行指定的操作，这个方法在很多地方都用到了，举例你在Context关联的线程之外想去执行一个action，但是这个action并不是在你当前所在的Vertx线程控制的范围内执行(例如你new Thread去执行)，现在你想要的是这个action会改变一些原来Vertx线程内的状态，如果想让这些改变的状态在这个context thread之中可见，就必须使用<code>runOnContext()</code>方法去执行。</p>
<p><code>executeAsync()</code>方法中的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">    <span class="comment">// No metrics, we are on the event loop.</span></div><div class="line">    nettyEventLoop().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, <span class="keyword">null</span>));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="ContextImpl-nettyEventLoop"><a href="#ContextImpl-nettyEventLoop" class="headerlink" title="ContextImpl#nettyEventLoop()"></a>ContextImpl#nettyEventLoop()</h5><p><code>nettyEventLoop()</code>方法在<code>ContextImpl</code>类中，返回持有的EventLoop实例，而这个EventLoop instance除非自己指定，否则是使用在<code>ContextImpl</code>的Constructor中传入的<code>VertxInternal</code>对象获取的，通过这个vertx对象的<code>getEventLoopGroup()</code>方法拿到EventLoopGroup，接着从Netty的<code>EventLoopGroup</code>中通过<code>next()</code>方法选出一个<code>EventLoop</code>作为返回值，注意这里的<code>EventLoopGroup</code>和<code>EventLoop</code>是Netty中的概念。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> EventLoop <span class="title">getEventLoop</span><span class="params">(VertxInternal vertx)</span> </span>&#123;</div><div class="line">  EventLoopGroup group = vertx.getEventLoopGroup();</div><div class="line">  <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> group.next();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这段是《Netty in Action》中提到的Channel,EventLoop,Thread以及EventLoopGroup之间的关系：</p>
<ul>
<li><p>一个EventLoopGroup包含一个或者多个EventLoop</p>
</li>
<li><p>一个EventLoop在它的生命周期内之和一个Thread关联</p>
</li>
<li><p>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理</p>
</li>
<li><p>一个Channel在它的生命周期内只会注册到一个EventLoop</p>
</li>
<li><p>一个EventLoop可能会指派到一个或多个Channel</p>
<p>在这种设计中，一个给定Channel的I/O操作都是由相同的Thread执行的，实际上消除了对于同步的需要。</p>
</li>
</ul>
</blockquote>
<p>这样就从netty的<code>EventLoopGroup</code>中拿到了<code>EventLoop</code>，接下来就是用<code>wrapTask()</code>方法将Vert.x中的要处理的event封装成Runnable接口提交给Netty的EventLoop了。</p>
<blockquote>
<p>注：提交的EventLoop不仅仅是NioEventLoop, Vert.x在3.5.0版本加入了对Linux上Epoll和OS X上Kqueue的Native Transport支持，Netty中的异步传输可以不再只是使用NIO了。关于Netty中EventLoop为什么使用<code>execute()</code>方法接收Runnable接口，可以去找一找相关的EventLoop和JUC中Executor的资料。</p>
</blockquote>
<p>我们对<code>wrapTask()</code>方法进行简化，省去一些Metrics管理，时间记录，检查操作的逻辑以及错误处理，得到的源码是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">wrapTask</span><span class="params">(ContextTask cTask, Handler&lt;Void&gt; hTask, <span class="keyword">boolean</span> checkThread, PoolMetrics metrics)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> () -&gt; &#123;</div><div class="line">      Thread th = Thread.currentThread();</div><div class="line">      VertxThread current = (VertxThread) th;</div><div class="line">      contextThread = current;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        setContext(current, ContextImpl.<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (cTask != <span class="keyword">null</span>) &#123;</div><div class="line">          cTask.run();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          hTask.handle(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// handle t</span></div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// clean up</span></div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到简化后的<code>wrapTask()</code>方法并没有太复杂的操作，仅仅将<code>executeAsync(Handler&lt;Void&gt; task)</code>方法传入的参数task封装成一个<code>Runnable</code>，做一些基本的检查线程的操作，交给<code>hTask.handle(null)</code>处理就行了。需要注意的只有一点，就是这个<code>Runnable</code>执行前会将它<strong>执行</strong>时的线程(必须是Vertx线程)与你调用<code>runOnContext()</code>方法的<strong>context</strong>关联。到现在可以确认的是，我们已经知道从Vert.x EventLoopContext上拿到的Task已经能够在Netty的EventLoop上面跑了。</p>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p><code>EventLoopContext</code>的构造器调用的是父类的构造器，现在我们将目光转向ContextImpl类。</p>
<h3 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h3><p>ContextImpl这个抽象类，内容非常的多。<br><img src="/2017/11/27/深入理解Vert.x Core(1)-Context/ContextImpl.png" alt="ShowImage"></p>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>按照顺序逐个分析，Logger不必说，先看六个常量，分别对应三组Key-Value，String常量表示Key，Boolean常量表示Value。<code>THREAD_CHECKS_PROP_NAME</code>对应<code>THREAD_CHECKS</code>，负责进行线程检查的开关；<code>DISABLE_TIMINGS_PROP_NAME</code>对应<code>DISABLE_TIMINGS</code>，负责进行时间计量的开关；<code>DISABLE_TCCL_PROP_NAME</code>对应<code>DISABLE_TCCL</code>，负责TCCL线程上下文类加载器的检测的开关。</p>
<h4 id="VertxInternal"><a href="#VertxInternal" class="headerlink" title="VertxInternal"></a>VertxInternal</h4><p><code>owner</code>变量很直观，就是对当前的Vertx引用，之前讲过一个Vert.x实例会有多个Eventloops，而每个EventLoop同一时间只会关联一个Context，反过来想一个Context也就对应一个Vert.x实例。这里类型是VertxInternal，主要面向内部使用。</p>
<h4 id="deploymentID-config"><a href="#deploymentID-config" class="headerlink" title="deploymentID, config"></a>deploymentID, config</h4><p>然后是<code>deploymentID</code>和<code>config</code>两个变量，这两个变量不复杂，找到相关联的地方就知道是给Verticle使用的属性，其中<code>deploymentID</code>通过<code>generateDeploymentID()</code>这个方法生成，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateDeploymentID</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> UUID.randomUUID().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在部署Verticle时候作为返回结果，而<code>config</code>就是部署Verticle时<code>DeploymentOptions</code>这个对象所包含的config属性的拷贝。前面也讲过了每个Verticle实例都会关联到唯一的一个Context，如果你看一眼<code>AbstractVerticle</code>里面的<code>deploymentID()</code>与<code>config()</code>方法，你会发现它们都调用的是所关联的context的对应方法。</p>
<h4 id="closeHooks"><a href="#closeHooks" class="headerlink" title="closeHooks"></a>closeHooks</h4><p>closeHooks提供了提醒自动清理的功能，在Verticle或者Vertx实例关闭的时候，上面跑的组件如果有closeHooks就可以实现自动清理。这个功能主要通过观察者模式实现，有兴趣可以结合源码并参考这篇文章看看。<br><a href="https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Close_hooks.adoc" target="_blank" rel="external">https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Close_hooks.adoc</a></p>
<h4 id="tccl"><a href="#tccl" class="headerlink" title="tccl"></a>tccl</h4><p>Context所在线程的Thread Context ClassLoader，通过构造器和set方法进行设置。</p>
<h4 id="eventLoop"><a href="#eventLoop" class="headerlink" title="eventLoop"></a>eventLoop</h4><p>Context对应的Netty的EventLoop实例，之前在讲<code>EventLoopContext</code>时候已经提过了。</p>
<h4 id="contextThread"><a href="#contextThread" class="headerlink" title="contextThread"></a>contextThread</h4><p>当前Context所关联的VertxThread实例，在<code>ContextImpl</code>类主要被用来做一些检查操作。</p>
<h4 id="contextData"><a href="#contextData" class="headerlink" title="contextData"></a>contextData</h4><p>这个官方文档说的非常明白，contextData就是让你可以在同一个Context的handlers之间共享任意类型的数据，通过<code>put()</code>,<code>get()</code>,<code>remove()</code>方法进行操作，数据结构就是<code>ConcurrentHashMap</code>。</p>
<p>获取contextData对象的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ConcurrentMap&lt;Object, Object&gt; <span class="title">contextData</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (contextData == <span class="keyword">null</span>) &#123;</div><div class="line">    contextData = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> contextData;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="exceptionHandler"><a href="#exceptionHandler" class="headerlink" title="exceptionHandler"></a>exceptionHandler</h4><p>为Context注册一个exceptionHandler，如果Context执行的action抛出异常自己无法捕获时，就会使用这个Context本身的exceptionHandler。<br>可以自己显式地调用<code>exceptionHandler(Handler&lt;Throwable&gt; handler)</code>方法去给context注册，还可以通过关联的VertxInternal实例中的exceptionHandler注册。<br>还是<code>ContextImpl</code>中的<code>wrapTask()</code>方法，看下怎么处理异常的，把逻辑简化下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">wrapTask</span><span class="params">(ContextTask cTask, Handler&lt;Void&gt; hTask, <span class="keyword">boolean</span> checkThread, PoolMetrics metrics)</span> </span>&#123;</div><div class="line">  <span class="comment">// metrics</span></div><div class="line">  <span class="keyword">return</span> () -&gt; &#123;</div><div class="line">    <span class="comment">// some checks...</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// logic</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      log.error(<span class="string">"Unhandled exception"</span>, t);</div><div class="line">      Handler&lt;Throwable&gt; handler = <span class="keyword">this</span>.exceptionHandler;</div><div class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">        handler = owner.exceptionHandler();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">        handler.handle(t);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// clean up</span></div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果try块中action自己处理不了异常，那么就先交给context的exceptionHandler来处理。如果这个exceptionHandler为空，就会使用关联的owner的exceptionHandler处理。</p>
<h4 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h4><p>Vert.x中verticle的deploy与undeploy操作都是交给DeploymentManager或者HAManager去处理的，Context中deployment对象就是一个<code>DeploymentImpl</code>实例，<code>DeploymentImpl</code>类是<code>DeploymentManager</code>类中的一个内部类，实现了<code>Deployment</code>接口，任务就是负责维护与Context相关联的Verticle的状态。<code>ContextImpl</code>中<code>getInstanceCount()</code>方法就是调用deployment实例中<code>deploymentOptions()</code>方法来获取verticle instance数量。</p>
<h4 id="processArgs-方法"><a href="#processArgs-方法" class="headerlink" title="processArgs()方法"></a>processArgs()方法</h4><p>从Launcher命令行获取到的参数，如果没有使用Launcher(拿到参数为null)那么就返回Starter的参数。<code>AbstractVerticle</code>#<code>processArgs()</code>方法调用的也是context的<code>processArgs()</code>方法。</p>
<blockquote>
<p>注：Starter已经Deprecated，一般都会使用Launcher。</p>
</blockquote>
<h4 id="setContext-静态方法"><a href="#setContext-静态方法" class="headerlink" title="setContext()静态方法"></a>setContext()静态方法</h4><p>将调用时所在的当前线程与指定Context关联起来。</p>
<h4 id="executeFromIO-方法"><a href="#executeFromIO-方法" class="headerlink" title="executeFromIO()方法"></a>executeFromIO()方法</h4><p>先看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeFromIO</span><span class="params">(ContextTask task)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (THREAD_CHECKS) &#123;</div><div class="line">    checkCorrectThread();</div><div class="line">  &#125;</div><div class="line">  wrapTask(task, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">null</span>).run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法接受一个ContextTask参数，ContextTask是一个函数接口。经过线程检查以后，执行的是<code>wrapTask(task, null, true, null).run();</code>。这个方法当第一个参数不为空时，调用的是<code>cTask.run()</code>而不是<code>hTask.handle(null)</code>，也就是说直接在当前线程上执行该task。<code>executeFromIO()</code>方法什么时候去调用它呢？就是当你需要在IO环境中去执行一些代码，比如说你需要在Netty代码中的<code>ChannelFuture</code>去处理一些Vert.x的handler回调逻辑时，这个时候就必须有一个对vert.x context的引用，然后用这个context的<code>executeFromIO()</code>方法去处理你的Vert.x API的逻辑。</p>
<h4 id="多余的一些字段和方法"><a href="#多余的一些字段和方法" class="headerlink" title="多余的一些字段和方法"></a>多余的一些字段和方法</h4><p><code>isOnWorkerThread()</code><br><code>isOnEventLoopThread()</code><br><code>isOnVertxThread()</code><br><code>isWorkerContext()</code><br><code>isEventLoopContext()</code><br><code>isMultiThreadedWorkerContext()</code><br>这些方法都能从字面上理解，源码也不复杂，这里就省略了</p>
<h4 id="还有一些非常重要的Stuff"><a href="#还有一些非常重要的Stuff" class="headerlink" title="还有一些非常重要的Stuff"></a>还有一些非常重要的Stuff</h4><p>在谈WorkerContext之前，还需要更加深入<code>ContextImpl</code>，前面讲<code>EventLoopContext</code>的时候说的比较简略，现在我们dive deeper一些。</p>
<h5 id="Constructor-1"><a href="#Constructor-1" class="headerlink" title="Constructor"></a>Constructor</h5><p>先回到<code>ContextImpl</code>类的构造器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ContextImpl</span><span class="params">(VertxInternal vertx, WorkerPool internalBlockingPool, WorkerPool workerPool, String deploymentID, JsonObject config,</span></span></div><div class="line">                        ClassLoader tccl) &#123;</div><div class="line">    <span class="keyword">this</span>(vertx, getEventLoop(vertx), internalBlockingPool, workerPool, deploymentID, config, tccl);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>getEventLoop()</code>这个方法之前已经讲过了，我们将目光转向这两个字段<code>internalBlockingPool</code>跟<code>workerPool</code>。查看类型发现它们都是WorkerPool，<code>WorkerPool</code>就是包装了一个<code>ExecutorService</code>与<code>PoolMetrics</code>的类，那么它们两个Pool之间有什么区别呢？首先来看一看internalBlockingPool的工作目的，这个pool是给Vert.x内部进行的阻塞操作使用，比如你使用FileSystem的一些操作或者AsyncFile的flush操作时，Vert.x会将这些阻塞的操作交给<code>internalBlockingPool</code>而不是<code>workerPool</code>去处理。与之相对的<code>workerPool</code>就是提供给用户来进行阻塞操作的pool。</p>
<h5 id="TaskQueue"><a href="#TaskQueue" class="headerlink" title="TaskQueue"></a>TaskQueue</h5><p><code>ContextImpl</code>中还有两个<code>TaskQueue</code>，这个类的目的很明确</p>
<blockquote>
<p>A task queue that always run all tasks in order.</p>
</blockquote>
<p><img src="/2017/11/27/深入理解Vert.x Core(1)-Context/TaskQueue.png" alt="ShowImage"></p>
<p>剖析一下<code>TaskQueue</code>的结构，首先TaskQueue有一个<code>LinkedList&lt;Task&gt;</code>列表去维护当前TaskQueue队列中需要被执行的任务Task，其中<code>Task</code>是一个自定义的静态内部类，以及一个<code>Executor</code>引用表示当前的<code>Executor</code>，还有一个Runnable引用。TaskQueue的构造方法很简单，就是直接让自己的Runnable引用<code>runner</code>指向自己<code>run</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  runner = <span class="keyword">this</span>::run;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用队列的<code>execute()</code>方法可以执行一个新的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, Executor executor)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (tasks) &#123;</div><div class="line">    tasks.add(<span class="keyword">new</span> Task(task, executor));</div><div class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</div><div class="line">      current = executor;</div><div class="line">      executor.execute(runner);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先对队列进行同步操作，将当前task封装成<code>Task</code>对象加入tasks队列。判断当前任务是否执行完了，如果之前的任务执行完了才去执行当前这个任务，否则<code>execute()</code>只会将任务加到队列，然后退出循环，这样就保证了同一个队列<code>TaskQueue</code>内的任务是一个个执行的，如果任务发送过多而前面没有处理完，就会出现任务堆积。</p>
<p>接着是<code>run</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">    <span class="keyword">final</span> Task task;</div><div class="line">    <span class="keyword">synchronized</span> (tasks) &#123;</div><div class="line">      task = tasks.poll();</div><div class="line">      <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (task.exec != current) &#123;</div><div class="line">        tasks.addFirst(task);</div><div class="line">        task.exec.execute(runner);</div><div class="line">        current = task.exec;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      task.runnable.run();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      log.error(<span class="string">"Caught unexpected Throwable"</span>, t);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>先进入死循环，声明当前即将被执行的<code>task</code>， 接着对tasks进行同步避免冲突操作，通过<code>LinkedList</code>的<code>poll()</code>从队列头取出一个任务交给引用<code>task</code>。<br>这个时候会有一些条件的判断，如果取出的是null，说明队列中没有任务需要执行了，这个时候将<code>current</code>置为null，并且退出循环，这样下次进入循环的时候就能执行任务了。<br>如果取到任务后发现当前取到的任务关联的executor不是当前的<code>TaskQueue</code>中的current executor，那么将这个任务重新退回队列第一个，并且将<code>runner</code>加入与这个任务相关联的executor(执行会在稍后发生，这里不一定会立即执行)，并且将<code>TaskQueue</code>的current置为该executor，这个过程做完就退出循环。<br>如果之前两个条件都满足了，说明这个任务现在是可以执行的，那么直接使用<code>task.runnable.run();</code>执行阻塞操作。这里用一个流程图来看更直观一点。</p>
<p><img src="/2017/11/27/深入理解Vert.x Core(1)-Context/TaskQueueExecution.png" alt="ShowImage"></p>
<p>现在我们已经知道如何通过<code>TaskQueue</code>来保障阻塞操作执行的顺序。接下来看<code>executeBlocking()</code>方法</p>
<h5 id="executeBlocking-方法"><a href="#executeBlocking-方法" class="headerlink" title="executeBlocking()方法"></a>executeBlocking()方法</h5><p>在<code>ContextImpl</code>类中一共有5个<code>executeBlocking()</code>重载方法，一个一个来看他们的作用。<br>先看第一个方法代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Execute an internal task on the internal blocking ordered executor</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Action&lt;T&gt; action, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  executeBlocking(action, <span class="keyword">null</span>, resultHandler, internalBlockingPool.executor(), internalOrderedTasks, internalBlockingPool.metrics());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个代码已经有一行注释了，上面清楚地写着是按顺序执行一个internal的阻塞task。将当前context的internalBlockingPool executor与internal队列传入重载的<code>executeBlocking()</code>方法，现在来看这个重载方法的代码，所有的逻辑都是在这里完成的，省去Metrics和Timing部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Action&lt;T&gt; action, Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler,</span></span></div><div class="line">    Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler,</div><div class="line">    Executor exec, TaskQueue queue, PoolMetrics metrics) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Runnable command = () -&gt; &#123;</div><div class="line">      Future&lt;T&gt; res = Future.future();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (blockingCodeHandler != <span class="keyword">null</span>) &#123;</div><div class="line">          ContextImpl.setContext(<span class="keyword">this</span>);</div><div class="line">          blockingCodeHandler.handle(res);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          T result = action.perform();</div><div class="line">          res.complete(result);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        res.fail(e);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// omit this</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (resultHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        runOnContext(v -&gt; res.setHandler(resultHandler));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (queue != <span class="keyword">null</span>) &#123;</div><div class="line">      queue.execute(command, exec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      exec.execute(command);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">    <span class="comment">// omit this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先声明一个<code>Runnable</code>对象command对即将进行的阻塞操作进行封装，由于传入<code>blockingCodeHandler</code>为null，因此直接执行action，将结果告知给前面定义的Future中并且设置好resultHandler回调，最后就是将这个<code>command</code>交给internal队列去处理了，<code>queue.execute(command, exec);</code>使得在交给队列之前将这个任务与当前context下的<code>internalBlockingPool</code>的<code>executor</code>关联。</p>
<p>接下来就是这个重载方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  executeBlocking(blockingCodeHandler, <span class="keyword">true</span>, resultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法就是有序直接执行阻塞任务。继续下一层重载方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span> </span>&#123;</div><div class="line">  executeBlocking(<span class="keyword">null</span>, blockingCodeHandler, resultHandler, workerPool.executor(), ordered ? orderedTasks : <span class="keyword">null</span>, workerPool.metrics());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法会去指定执行的executor是<code>workerPool</code>中的executor，并且如果有序的话就用orderedTasks去保证执行任务的顺序，继续回到上面实现真正逻辑的重载方法。<br>这次<code>blockingCodeHandler</code>不为空，那么就将当前所在线程的context设置为正在用的context，并且将异步操作的结果通过future与resultHandler回调hook上。如果有序就用taskQueue保证任务的执行顺序，无序就直接丢给对应的executor执行。</p>
<p>还有最后一个方法是自己指定<code>TaskQueue</code>的重载方法，逻辑跟有序执行基本差不多，只不过<code>TaskQueue</code>是自己指定的，这里就省略了。</p>
<p>在理清了<code>ContextImpl</code>的一切之后，接下来看<code>WorkerContext</code>与<code>MultiThreadedWorkerContext</code>就没有那么复杂了。</p>
<h3 id="WorkerContext"><a href="#WorkerContext" class="headerlink" title="WorkerContext"></a>WorkerContext</h3><p><code>isEventLoopContext()</code>方法与<code>isMultiThreadedWorkerContext()</code>方法当然都返回false。接下来就是<code>executeAsync()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">  orderedTasks.execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, workerPool.metrics()), workerPool.executor());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到仅仅是将task封装成Runnable对象然后提交到TaskQueue中去执行。</p>
<h3 id="MultiThreadedWorkerContext"><a href="#MultiThreadedWorkerContext" class="headerlink" title="MultiThreadedWorkerContext"></a>MultiThreadedWorkerContext</h3><p><code>MultiThreadedWorkerContext</code>继承了<code>WorkerContext</code>，不同之处就是<code>isMultiThreadedWorkerContext()</code>方法与<code>executeAsync()</code>方法进行了重写。<br>前者不用说，直接看<code>executeAsync()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</div><div class="line">  workerPool.executor().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">false</span>, workerPool.metrics()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>MultiThreadedWorkerContext</code>中，<code>executeAsync()</code>方法会将task直接交给workerPool的executorService去处理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>一个线程可能会被多个Context所使用，但是一个Context只可能同时在一个线程执行，不可能出现一个Context同时关联多个线程的情况。</p>
</li>
<li><p>调用Vert.x的API时候，如果当前线程是Vert.x线程，那么此时就会复用这个Vert.x线程已经关联好的Context，如果不是就会创建一个新的Context。</p>
</li>
<li><p>一个Verticle 部署以后会关联一个新的Context，并且只对应这个Context，Context类型会由<code>DeploymentOptions</code>决定, 就是之前讲的三种类型。所有在Verticle里面执行的handler都会用Verticle关联的唯一的Context。另外，如果在Standard Verticle里面调用<code>executeBlocking()</code>方法执行阻塞代码，尽管任务被丢给worker pool里面的一个线程去执行，但Context这个时候还是<code>EventLoopContext</code>类型。</p>
</li>
</ol>

      
    </div>
    
    
    

    <div>
       
         
<div style="text-align:center;color: #ccc;font-size:15px;">
------ 本文结束 ------</div>
<br/>

<h1>版权声明</h1>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="http://pic01-1253683104.cosgz.myqcloud.com/cc%20by-nc-sa4.0.png"></a>
<br/>
<p style="font-size: 15px;line-height: 30px"><a href="http://www.billyyccc.com" style="color:#258FC6">BillyYccc's blog</a> by Billy Yuan is licensed under a <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#258FC6">Creative Commons BY-NC-SA 4.0 International License</a>.
<br>本文原创于<a href="http://www.billyyccc.com" style="color:#258FC6">BillyYccc's Blog</a>，转载请注明原作者及出处！</br></p>



       
    </div>


    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Vert-x/" rel="tag"># Vert.x</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/26/Vert.x核心组件概览/" rel="next" title="Vert.x核心组件概览">
                <i class="fa fa-chevron-left"></i> Vert.x核心组件概览
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/04/深入理解Vert.x Core(2)-Future/" rel="prev" title="深入理解Vert.x Core(2)-Future">
                深入理解Vert.x Core(2)-Future <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODQ1MC81MDIx"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Billy Yuan" />
            
              <p class="site-author-name" itemprop="name">Billy Yuan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/BillyYccc" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billy112487983@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/billyyccc" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Context"><span class="nav-number">1.</span> <span class="nav-text">Context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoopContext"><span class="nav-number">1.1.</span> <span class="nav-text">EventLoopContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#isEventLoopContext-isMultiThreadedWorkerContext"><span class="nav-number">1.1.1.</span> <span class="nav-text">isEventLoopContext(),isMultiThreadedWorkerContext()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#checkCorrectThread"><span class="nav-number">1.1.2.</span> <span class="nav-text">checkCorrectThread()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#executeAsync"><span class="nav-number">1.1.3.</span> <span class="nav-text">executeAsync()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ContextImpl-nettyEventLoop"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">ContextImpl#nettyEventLoop()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor"><span class="nav-number">1.1.4.</span> <span class="nav-text">Constructor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextImpl"><span class="nav-number">1.2.</span> <span class="nav-text">ContextImpl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties"><span class="nav-number">1.2.1.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VertxInternal"><span class="nav-number">1.2.2.</span> <span class="nav-text">VertxInternal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deploymentID-config"><span class="nav-number">1.2.3.</span> <span class="nav-text">deploymentID, config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#closeHooks"><span class="nav-number">1.2.4.</span> <span class="nav-text">closeHooks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tccl"><span class="nav-number">1.2.5.</span> <span class="nav-text">tccl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventLoop"><span class="nav-number">1.2.6.</span> <span class="nav-text">eventLoop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contextThread"><span class="nav-number">1.2.7.</span> <span class="nav-text">contextThread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contextData"><span class="nav-number">1.2.8.</span> <span class="nav-text">contextData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exceptionHandler"><span class="nav-number">1.2.9.</span> <span class="nav-text">exceptionHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deployment"><span class="nav-number">1.2.10.</span> <span class="nav-text">deployment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processArgs-方法"><span class="nav-number">1.2.11.</span> <span class="nav-text">processArgs()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setContext-静态方法"><span class="nav-number">1.2.12.</span> <span class="nav-text">setContext()静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#executeFromIO-方法"><span class="nav-number">1.2.13.</span> <span class="nav-text">executeFromIO()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多余的一些字段和方法"><span class="nav-number">1.2.14.</span> <span class="nav-text">多余的一些字段和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#还有一些非常重要的Stuff"><span class="nav-number">1.2.15.</span> <span class="nav-text">还有一些非常重要的Stuff</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructor-1"><span class="nav-number">1.2.15.1.</span> <span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TaskQueue"><span class="nav-number">1.2.15.2.</span> <span class="nav-text">TaskQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#executeBlocking-方法"><span class="nav-number">1.2.15.3.</span> <span class="nav-text">executeBlocking()方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WorkerContext"><span class="nav-number">1.3.</span> <span class="nav-text">WorkerContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MultiThreadedWorkerContext"><span class="nav-number">1.4.</span> <span class="nav-text">MultiThreadedWorkerContext</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">2.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Billy Yuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/BillyYccc/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "middleRight";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  

</body>
</html>
